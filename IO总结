I/O总结
I/O设备称为输入/输出设备，计算机发送数据是输出，接收数据是输入。
操作系统分为内核态和用户态两个空间。在操作系统的模型中，直接访问硬件的是内核（Kernel）。
一个服务端接收客户端的请求如下图所示：



1.当数据包存入内核缓冲区时，会触发中断，这里我理解的是硬中断，是网卡发送的中断信号。
2.上图仅表示已经创建好连接，然后互传信息的过程。






创建套接字的过程伴随着TCP的连接过程：

在连接过程中，其实就是write和read的过程。

对于一次IO访问，数据会先被拷贝到内核缓冲区，然后才从缓冲区拷贝到应用程序的地址空间。因此，一般有下面两个阶段：
(1)等待数据准备
(2)将数据从内核拷贝到进程

因为这两个阶段，linux产生了下面五种网络模式。
阻塞I/O
非阻塞I/O
I/O多路复用
信号驱动I/O
异步I/O








一、阻塞I/O

在linux中，默认所有的socket都是阻塞的。
当用户进程连接完毕开始接收数据时，如果数据还没有拷贝到内核缓冲区，或内核缓冲区还没有足够的数据时，内核的后续操作会被阻塞。
而用户进程这边，在数据拷贝到用户内存的阶段（接收数据），则会一直阻塞，直到操作系统将内核缓冲区的数据拷贝到用户内存中，才回解除阻塞。
因此实际上，在I/O操作的两个阶段，都有阻塞。

缺点:每当有一个客户端请求时，服务端都会创建一个新的线程。在高并发环境下，线程会特别多（因为有很多客户端请求，创建了大量线程），这导致多个线程抢占CPU资源，引起CPU的上下文切换，增加了系统开销。
二、非阻塞I/O

Linux下，可以通过设置socket使其变为non-blocking。
当用户进程发出read操作时，如果内核中的数据还没准备好，它并不会阻塞住用户进程，而是返回一个error。从用户进程的角度讲，它并没有等待，而是返回了一个结果。当用户进程发现返回的是error后，就再次发送read操作。如果内核中的数据准备好了，并且收到了read指令，就会将数据拷贝到用户内存。
因此，阻塞和非阻塞的主要区别就在于，调用阻塞IO会一直阻塞住对应进程直到操作完成，而非阻塞IO在内核还在准备数据的时候就会返回一个值，让用户进程不断轮询。
相同点在于，内核在拷贝数据到用户空间这个过程，进程始终是在阻塞的。
非阻塞IO解决了阻塞IO一个连接创建一个线程的缺点。在高并发下节省了创建线程的成本。

缺点：在轮询的过程中，会占用大量的CPU时间。（这个原因是我自己理解的，查了很多资料也没查到缺点，硬要说缺点的话可能这个算吧）













三、I/O多路复用


IO多路复用就是select，poll，epoll。select/poll的好处在于单个进程就可以处理多个网络连接的IO。基本原理就是select，poll，epoll这个function会不断轮询所有的socket，当某个socket有数据到了，就会通知用户进程。

当用户进程调用了select时，整个进程会被阻塞。内核会监视select负责的socket，一旦有socket的数据准备好了，select就会返回，进程解除阻塞，调用read将数据拷贝到用户空间。

这个IO多路复用使用select其实跟阻塞IO差不多，区别在于：
IO多路复用可以处理多个连接，而阻塞IO，一个线程只能处理一个连接。
而进程则是一直被阻塞，只不过是被select这个函数阻塞。

select，poll，epoll都是IO多路复用的机制。IO多路复用都是通过这种机制，让内核去监视多个socket，如果有socket完成，就通知进程进行相应的write/read指令。但select，poll，epoll本质上都是同步IO，因为他们都需要在读写时间就绪后（socket就绪）后再负责读写，也就是说，在就绪的这段时间里，进程始终是堵塞的。而异步IO，只需要进程发出一个IO操作指令（write/read），内核就会自己去等待数据进内核缓冲区，再将数据拷贝到用户内存。
所以无论是阻塞还是非阻塞还是多路复用，在内核将数据拷贝到用户空间这个过程，进程始终是处于阻塞状态下的。不同在于第一步数据拷贝到内核缓冲区的过程：
阻塞IO模型下，进程是被阻塞的。
非阻塞IO模型下，进程一直轮询，没有被阻塞。
IO多路复用模型下，进程被select函数阻塞。
四、模型演变

以基本任务的处理流程为例，首先是串行模型


可以看到，每次提交任务时，工作线程会接收该任务并做处理。这种模式的缺点显而易见，在没做完前一个任务之前，也不会接收下一个任务，浪费CPU资源。


针对串行模式的缺点，将任务的接收和处理变成两个线程去处理：

接收线程负责接收，工作线程负责处理，中间维护一个队列用来存放任务。这种模式的缺点，如果接收任务过多，而处理任务过慢，就导致接收任务队列的任务数量会越来越大。

针对上面模式的缺点，将处理任务改成并行，多个线程去处理任务队列的任务：

这种任务模式的缺点在于，由于是多个线程去操作任务队列，导致任务队列必须加锁来保证多线程环境下取数据的正确性。

于是，下面一种Reactor模型就出现了:

直接将任务分发给工作线程，每个工作线程自己维护一个任务队列，这种模式避免了锁的竞争。
